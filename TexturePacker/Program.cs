using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp.Processing;
using System.CommandLine;
using Point = SixLabors.ImageSharp.Point;
using Rectangle = SixLabors.ImageSharp.Rectangle;
using QuickType;
using Newtonsoft.Json;

// Full disclosure - no code was directly used, but I poked through these as my learning material:
// https://blackpawn.com/texts/lightmaps/default.html
// https://gist.github.com/ttalexander2/88a40eec0fd0ea5b31cc2453d6bbddad

// TODO: Duplicate removal
// TODO: Either make sprite padding actually extrude color, or only pad on one side per axis to save space.

class Program
{
    static async Task<int> Main(string[] args)
    {
        var rootCommand = new RootCommand("Texture packer. Shenanigans abound!!!");

        var enumCommand = new Command("enum", "Compiles a folder of enum files into a single target enum .cs file with the given namespace.");

        var dirOption = new Option<DirectoryInfo?>(
            name: "--input",
            description: "The directory to grab enum .cs files from.");

        var outputOption = new Option<FileInfo?>(
            name: "--output",
            description: "The output file.");

        var namespaceOption = new Option<string>(
            name: "--namespace",
            description: "The namespace for the output enums.");

        var nameOption = new Option<string>(
            name: "--name",
            description: "The name of the output file."
            );

        enumCommand.AddOption(dirOption);
        enumCommand.AddOption(outputOption);
        enumCommand.AddOption(namespaceOption);
        enumCommand.AddOption(nameOption);

        enumCommand.SetHandler((dir, output, name, nameSpace) =>
        {
            Enum(dir!, output!, name!, nameSpace!);
        },
            dirOption, outputOption, nameOption, namespaceOption);

        rootCommand.AddCommand(enumCommand);

        var packCommand = new Command("pack", "Packs textures from a folder into a texturepage, JSON metadata, and an enum file.");

        var dirOption2 = new Option<DirectoryInfo?>(
            name: "--input",
            description: "The directory to begin packing from.");

        var sizeOption = new Option<int>(
            name: "--size",
            description: "The size of the output texturepage, in pixels.",
            getDefaultValue: () => 2048);

        var outputOption2 = new Option<DirectoryInfo?>(
            name: "--output",
            description: "The output directory for the resulting texturepage.");

        var nameOption2 = new Option<string>(
            name: "--name",
            description: "The name of the output file."
            );

        packCommand.AddOption(dirOption2);
        packCommand.AddOption(sizeOption);
        packCommand.AddOption(outputOption2);
        packCommand.AddOption(nameOption2);

        packCommand.SetHandler((dir, size, output, name) =>
        {
            Pack(dir!, size!, output!, name!);
        },
            dirOption2, sizeOption, outputOption2, nameOption2);


        rootCommand.AddCommand(packCommand);

        return await rootCommand.InvokeAsync(args);
    }


    private static readonly List<Sprite> Sprites = new();
    private static readonly List<Frame> Frames = new();
    private static string _exportJson = "{\"sprites\":{\n";

    private const string ENUM_FILE_HEADER = @"
/*
 * WARNING: This file is auto-generated by the texture packer!!!
 *          Modifications to it will be overwritten the next time the texture packer is run.
 */


";

    private static void Enum(DirectoryInfo dir, FileSystemInfo output, string name, string nameSpace)
    {
        var enumOut = ENUM_FILE_HEADER + "namespace " + nameSpace + ";\n\npublic enum " + name + " {";

        List<string> entries = new();
        
        foreach (var file in dir.GetFiles())
        {
            var all = File.ReadAllText(file.FullName);
            var lines = all.Split("\n");
            foreach (var line in lines)
            {
                entries.Add(line);
            }
        }

        var finalEntries = entries.Distinct().ToList();

        foreach (var entry in finalEntries)
        {
            enumOut += "\n\t" + entry;
        }

        enumOut += "\n}";

        File.WriteAllText(output.FullName, enumOut);
    }

    private static void Pack(DirectoryInfo dir, int size, DirectoryInfo outDir, string name)
    {
        // Add sprites to list
        RecursiveAdd(dir);

        // Sort list from largest to smallest. I am lying to the computer here to get the largest images FIRST (inverting 1/-1).
        Frames.Sort(delegate(Frame x, Frame y)
        {
            // X is smaller
            if (x.Height < y.Height)
                return 1;

            // Y is smaller
            if (y.Height < x.Height)
                return -1;

            // Both are equal
            return 0;
        });

        Node root = new(new Rectangle(0, 0, size, size));

        var enumOutput = "";

        foreach (var frame in Frames)
        {
            var node = root.Insert(frame);
            if (node != null)
            {
                frame.Parent.Positions[frame.Index] = new FakeRectangle(node.Bounds.X + 1, node.Bounds.Y + 1, node.Bounds.Width - 2,
                    node.Bounds.Height - 2);
            }
        }

        foreach (var sprite in Sprites)
        {
            _exportJson += sprite + ",\n";
            enumOutput += sprite.Metadata.Name + ",\n";
        }

        _exportJson += "}}";

        File.WriteAllText(outDir + "/" + name + ".json", _exportJson);

        if (!Directory.Exists(outDir + "/enums"))
            Directory.CreateDirectory(outDir + "/enums");

        

        File.AppendAllText(outDir + "/enums/pages.enumPart", name + ",\n");

        if (!Directory.Exists(outDir + "/enums/sprites"))
            Directory.CreateDirectory(outDir + "/enums/sprites");
        
        File.WriteAllText(outDir + "/enums/sprites/" + name + ".enumPart", enumOutput);

        Image<Rgba32> canvas = new(size, size);

        root.Render(canvas);

        canvas.SaveAsPng(outDir + "/" + name + ".png");
    }

    private static void RecursiveAdd(DirectoryInfo directory)
    {
        FileInfo? metadata = null;
        List<string> names = new();
        List<Image> frames = new();

        foreach (var file in directory.GetFiles())
        {
            if (file.Extension == ".png")
                names.Add(file.FullName);
            else if (file.Name == "mdat.json")
                metadata = file;
        }
        
        names.Sort((strX, strY) =>
        {
            var x = int.Parse(Path.GetFileNameWithoutExtension(strX));
            var y = int.Parse(Path.GetFileNameWithoutExtension(strY));

            if (x == y) 
                return 0;

            return x < y ? -1 : 1;
        });

        var trueWidth = 0;
        var trueHeight = 0;
        
        var cropOffsets = new int[names.Count][];
        
        for (var n = 0; n < names.Count; n++)
        {
            var name = names[n];
            var img = Image.Load<Rgba32>(name);

            if (n == 0)
            {
                trueWidth = img.Width;
                trueHeight = img.Height;
            }
            
            var cropLeft = img.Width;
            var cropRight = 0;
            var cropTop = img.Height;
            var cropBottom = 0;

            for (var i = 0; i < img.Width; i++)
            {
                for (var j = 0; j < img.Height; j++)
                {
                    if (img[i, j].A <= 0) 
                        continue;
                    
                    if (i < cropLeft)
                        cropLeft = i;
                    if (i > cropRight)
                        cropRight = i;

                    if (j < cropTop)
                        cropTop = j;
                    if (j > cropBottom)
                        cropBottom = j;
                }
            }
            
            if (cropLeft != 0 || cropRight != img.Width || cropTop != 0 || cropBottom != img.Height)
                img.Mutate(x => x.Crop(new Rectangle(cropLeft, cropTop, 1 + cropRight - cropLeft, 1 + cropBottom - cropTop)).Pad(img.Width + 2, img.Height + 2));

            frames.Add(img);
            
            cropOffsets[n] = new[] { cropLeft, cropTop };
        }

        if (metadata != null)
        {
            var spr = new Sprite(metadata, trueWidth, trueHeight, cropOffsets);
            
            Sprites.Add(spr);
            for (var i = 0; i < frames.Count; i++)
            {
                Frames.Add(new Frame(frames[i], spr, i));
            }
        }

        foreach (var dir in directory.GetDirectories())
        {
            RecursiveAdd(dir);
        }
    }

    private sealed class Frame
    {
        public readonly Image Data;
        public readonly Sprite Parent;
        public readonly int Index;

        public int Width => Data.Width;
        public int Height => Data.Height;

        public Frame(Image data, Sprite parent, int index)
        {
            Data = data;
            Parent = parent;
            Index = index;
        }
    }

    private sealed class Sprite
    {
        public readonly Metadata Metadata;
        public readonly FakeRectangle[] Positions;
        private readonly int _width;
        private readonly int _height;
        private readonly int[][] CropOffsets;

        public Sprite(FileSystemInfo metadata, int width, int height, int[][] cropOffsets)
        {
            Metadata = Metadata.FromJson(File.ReadAllText(metadata.FullName));
            Positions = new FakeRectangle[Metadata.FrameCount];
            _width = width;
            _height = height;
            CropOffsets = cropOffsets;
        }

        public override string ToString()
        {
            var md = Export();

            return "\"" + Metadata.Name + "\":" + JsonConvert.SerializeObject(md);
        }

        private MetadataFinal Export()
        {
            MetadataFinal md = new()
            {
                Length = Metadata.FrameCount,
                OriginX = Metadata.Origin[0],
                OriginY = Metadata.Origin[1],
                AttachPoints = Metadata.AttachPoints,
                Positions = Positions,
                Width = _width,
                Height = _height,
                CropOffsets = CropOffsets
            };

            return md;
        }
    }

    private sealed class Node
    {
        private Node? _left;
        private Node? _right;
        public Rectangle Bounds;
        private Image? _sprite;

        public Node(Rectangle bounds)
        {
            Bounds = bounds;
        }

        public Node? Insert(Frame frame)
        {
            var sprite = frame.Data;
            
            // If we already have an image, or the image doesn't fit...
            if (_sprite != null || !Fits(sprite))
                // ...attempt to insert right, then attempt to insert left, and finally return null if neither of those worked.
                return _right?.Insert(frame) ?? _left?.Insert(frame);
            
            // Otherwise, the image fits so we should take it and try to create more space for other images.
            _sprite = sprite;

            // Width still has room - create new Node
            if (Bounds.Width - _sprite.Width > 0)
                _right = new Node(new Rectangle(Bounds.X + _sprite.Width, Bounds.Y, Bounds.Width - _sprite.Width, _sprite.Height));

            // Height still has room - create new Node
            if (Bounds.Height - _sprite.Height > 0)
                _left = new Node(new Rectangle(Bounds.X, Bounds.Y + _sprite.Height, Bounds.Width, Bounds.Height - _sprite.Height));

            // Set bounds to match sprite
            Bounds = new Rectangle(Bounds.X, Bounds.Y, _sprite.Width, _sprite.Height);

            return this;
        }

        public void Render(Image canvas)
        {
            if (_sprite != null)
            {
                canvas.Mutate(c => c.DrawImage(_sprite, new Point(Bounds.X, Bounds.Y), 1f));
            }

            _left?.Render(canvas);
            _right?.Render(canvas);
        }

        private bool Fits(Image sprite)
        {
            var bounds = sprite.Bounds;
            bounds.X = Bounds.X;
            bounds.Y = Bounds.Y;
            return Bounds.Contains(bounds);
        }
    }

}

// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var metadata = Metadata.FromJson(jsonString);


namespace QuickType
{
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public sealed class Metadata
    {
        [JsonProperty("frameCount")]
        public int FrameCount { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("origin")]
        public int[] Origin { get; set; }

        [JsonProperty("attachPoints")]
        public Dictionary<string, int[][]> AttachPoints { get; set; }

        public static Metadata FromJson(string json) => JsonConvert.DeserializeObject<Metadata>(json, QuickType.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Metadata self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
        public static string ToJson(this MetadataFinal self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }


    public class MetadataFinal
    {
        [JsonProperty("length")]
        public int Length { get; set; }

        [JsonProperty("originX")]
        public int OriginX { get; set; }

        [JsonProperty("originY")]
        public int OriginY { get; set; }

        [JsonProperty("attachPoints")]
        public Dictionary<string, int[][]> AttachPoints { get; set; }

        [JsonProperty("positions")]
        public FakeRectangle[] Positions { get; set; }

        [JsonProperty("width")]
        public int Width { get; set; }
        
        [JsonProperty("height")]
        public int Height { get; set; }
        
        [JsonProperty("cropOffsets")]
        public int[][] CropOffsets { get; set; }

        public static MetadataFinal FromJson(string json) => JsonConvert.DeserializeObject<MetadataFinal>(json, QuickType.Converter.Settings);
    }

    public class FakeRectangle
    {
        public int X { get; set; }
        public int Y { get; set; }
        public int Width { get; set; }
        public int Height { get; set; }

        public FakeRectangle(int x, int y, int width, int height)
        {
            X = x;
            Y = y;
            Width = width;
            Height = height;
        }
    }
}