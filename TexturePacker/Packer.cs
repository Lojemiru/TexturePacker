using System.Diagnostics;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using TexturePacker.Models;

namespace TexturePacker;

public static class Packer
{
    private static readonly List<Sprite> Sprites = new();
    private static readonly List<Frame> Frames = new();

    private static readonly List<string> SpriteNames = new();
    private static readonly List<string> PageNames = new();

    private const string ENUM_FILE_HEADER = @"
/*
 * WARNING: This file is auto-generated by Lojemiru's TexturePacker!!!
 *          Modifications to it will likely be overwritten the next time the packer is run.
 */


";

    #region PAGES

    /// <summary>
    /// Loads all sprites from the given <see cref="DirectoryInfo"/>, generating their individual images and metadata.
    /// </summary>
    /// <param name="directory">The directory from which to load the sprites.</param>
    private static void LoadSprites(DirectoryInfo directory)
    {
        // Load only aseprite files from the group...
        foreach (var file in directory.GetFiles("*.aseprite"))
        {
            // Load Aseprite, map its layers, and create our new Sprite.
            var ase = new Aseprite(file.FullName);
            var layers = MapLayers(ase);
            var sprite = new Sprite(Path.GetFileNameWithoutExtension(file.Name), ase.Width, ase.Height, layers.Count, ase.FrameCount);
            
            Sprites.Add(sprite);

            // Set up crop offset and frame position data structures for later population.
            int i;
            for (i = 0; i < sprite.Layers; i++)
            {
                sprite.CropOffsets![i] = new int[sprite.Length][];
                sprite.Positions[i] = new FakeRectangle[sprite.Length];
            }

            // Set up first layer of attach points data structure.
            var attachPoints = new Dictionary<string, Dictionary<int, int[]>>();
            
            // Set up second layer of attach points data structure. Specifically, this pulls in all the attach point names.
            foreach (var layer in ase.Layers)
            {
                if (!layer.Name.StartsWith("_attach_")) 
                    continue;
                    
                var name = layer.Name.Replace("_attach_", "");
                attachPoints[name] = new Dictionary<int, int[]>();
            }
            
            // Iterate over all frames and parse all cels within each frame.
            for (i = 0; i < ase.FrameCount; i++)
            {
                foreach (var cel in ase.Frames[i].Cels)
                {
                    ParseCelData(cel, sprite, i, layers, attachPoints);
                }
            }
            
            // Finalize attach point data. We intentionally want to end the array early if the end user did not fill out
            // all cels within the attach point layer, so we have to do this after everything else.
            foreach (var layer in attachPoints.Keys)
            {
                var count = attachPoints[layer].Count;
                sprite.AttachPoints[layer] = new int[count][];
                    
                for (i = 0; i < count; i++)
                {
                    sprite.AttachPoints[layer][i] = attachPoints[layer][i];
                }
            }
        }
    }
    
    /// <summary>
    /// Maps all non-data layers from the given <see cref="Aseprite"/> into a <see cref="List{T}"/>.
    /// </summary>
    /// <param name="aseprite">The sprite whose layers should be mapped.</param>
    /// <returns>A list of all non-data layers in this sprite.</returns>
    private static List<string> MapLayers(Aseprite aseprite)
    {
        var output = new List<string>();

        foreach (var layer in aseprite.Layers)
        {
            if (layer.Name.StartsWith('_'))
                continue;
            
            output.Add(layer.Name);
        }

        return output;
    }
    
    /// <summary>
    /// Packs texture groups into texture atlases and metadata JSON.
    /// </summary>
    /// <param name="dir">The directory to search for texture groups.</param>
    /// <param name="outDir">The output directory.</param>
    /// <param name="outDirEnums">The output directory for enum data. Enums are not generated if this field is null.</param>
    /// <param name="nameSpace">The namespace to use for the output enums. Unused if <see cref="outDirEnums"/> is null.</param>
    public static void PackAllPages(DirectoryInfo dir, DirectoryInfo outDir, DirectoryInfo? outDirEnums, string nameSpace)
    {
        // Throw if user is being silly and sets output to input.
        if (dir == outDir)
            throw new ArgumentException("Input directory is the same as the output directory!");

        // Create output directory if it does not exist.
        if (!Directory.Exists(outDir.FullName))
            Directory.CreateDirectory(outDir.FullName);

        // Delete all files in output folder.
        foreach (var file in outDir.GetFiles())
        {
            if (file.Name.EndsWith(".json") || file.Name.EndsWith(".png"))
                file.Delete();
        }
        
        var stopWatch = new Stopwatch();
        stopWatch.Start();
        
        // Pack all texture groups found in input directory.
        foreach (var page in dir.GetDirectories())
        {
            PackPage(page, outDir);
        }
        
        stopWatch.Stop();
        Console.WriteLine("Packed " + PageNames.Count + " pages (" + SpriteNames.Count + " sprites total) in " + stopWatch.Elapsed);

        // Exit if outDirEnums is not set.
        if (outDirEnums is null) 
            return;

        // Wipe old enum files from output folder.
        if (Directory.Exists(outDirEnums.FullName))
        {
            foreach (var file in outDirEnums.GetFiles("*.cs"))
            {
                file.Delete();
            }
        }

        // Create folder if it doesn't exist.
        if (!Directory.Exists(outDirEnums.FullName))
            Directory.CreateDirectory(outDirEnums.FullName);

        // Write out enums for both pages and sprites.
        WriteEnum("PageIndex", nameSpace, PageNames, outDirEnums);
        WriteEnum("SpriteIndex", nameSpace, SpriteNames, outDirEnums);
    }

    /// <summary>
    /// Packs a single texture group into a texture atlas and JSON metadata.
    /// </summary>
    /// <param name="dir">The input texture group.</param>
    /// <param name="outDir">The output directory.</param>
    private static void PackPage(DirectoryInfo dir, DirectoryInfo outDir)
    {
        // Clear sprite/frame lists.
        Sprites.Clear();
        Frames.Clear();
        
        // Get options, load defaults if file does not exist.
        var options = File.Exists(dir + "/PageOptions.json") 
            ? PageOptions.FromJson(File.ReadAllText(dir + "/PageOptions.json")) 
            : new PageOptions();

        var name = dir.Name;
        
        Console.WriteLine("Packing page " + name + "...");

        PageNames.Add(name);
        
        // Load all sprite data from group.
        LoadSprites(dir);

        // Sort list from largest to smallest based on height.
        // I am lying to the computer here to get the largest images FIRST (inverting 1/-1).
        Frames.Sort(delegate(Frame x, Frame y)
        {
            // X is smaller.
            if (x.Height < y.Height)
                return 1;

            // Y is smaller.
            if (y.Height < x.Height)
                return -1;

            // Both are equal.
            return 0;
        });
        
        // Create root node for packing.
        Node root = new(new Rectangle(0, 0, options.Size, options.Size));

        // Insert each frame into the texture page tree.
        foreach (var frame in Frames)
        {
            var node = root.Insert(frame.Data);
            if (node != null)
            {
                // Record positions to the parent Sprite for the JSON metadata.
                frame.Parent.Positions[frame.Layer][frame.Index] = new FakeRectangle(node.Bounds.X + 1, 
                    node.Bounds.Y + 1, node.Bounds.Width - 2, node.Bounds.Height - 2);
            }
        }

        var exportJson = "{\"sprites\":{\n";
        
        // Composite JSON metadata from all sprites in this page.
        foreach (var sprite in Sprites)
        {
            exportJson += sprite + ",\n";
            
            // Store sprite name for later enum generation.
            SpriteNames.Add(sprite.Name);
        }

        exportJson += "}}";
        
        // Export JSON metadata.
        File.WriteAllText(outDir + "/" + name + ".json", exportJson);

        // Render atlas.
        var atlas = new Image<Rgba32>(options.Size, options.Size);
        root.Render(atlas);
        
        // Save atlas to disk.
        atlas.SaveAsPng(outDir + "/" + name + ".png");
    }

    /// <summary>
    /// Parses all data from the given <see cref="Aseprite.Cel"/> and adds it to the relevant data structures.
    /// </summary>
    /// <param name="cel">The Cel to parse.</param>
    /// <param name="parent">The parent Sprite of this Cel.</param>
    /// <param name="index">Index of the Frame to which this Cel belongs.</param>
    /// <param name="layers">List of layer names generated by <see cref="MapLayers"/>.</param>
    /// <param name="attachPoints">The Dictionary{T, K} in which to store attach point data.</param>
    /// <exception cref="Exception">Thrown if a data layer contains more than one pixel.</exception>
    private static void ParseCelData(Aseprite.Cel cel, Sprite parent, int index, List<string> layers, 
        Dictionary<string, Dictionary<int, int[]>> attachPoints)
    {
        var layer = cel.Layer.Name;

        // Image layers: load image data from Cel bytes, conduct cropping, and add to the frame list.
        if (!layer.StartsWith('_'))
        {
            // if you're wandering in here wondering why special blend modes are busted it's probably because we are
            // directly reading the bytes into an image. I do not care about this behavior right now so I'm not doing
            // the extra work to support it but you probably want to add some stuff to Aseprite.cs and then read pixels
            // instead of bytes
            var img = Image.LoadPixelData<Rgba32>(cel.Bytes, cel.Width, cel.Height);
            var layerIndex = layers.IndexOf(layer);
            
            img.Crop(cel, parent, layerIndex, index);
            
            Frames.Add(new Frame(img, parent, index, layerIndex));
        }
        // Attach points: determine attach point position and record it to the temporary attach points list.
        else if (layer.StartsWith("_attach_"))
        {
            if (cel.Pixels.Length > 1)
            {
                // We could technically just traverse all the pixels and find the first one with a high alpha value... but it's better to just make people do it right.
                Console.WriteLine("[ERROR]: Sprite " + parent.Name + " has an attach layer with more than one pixel. This may be due to an uncropped canvas. Ungracefully exiting packing!!!");
                throw new Exception("Please see the above error message.");
            }
            
            var name = layer.Replace("_attach_", "");

            attachPoints[name][index] = new[] { cel.X, cel.Y };
        }
        // Origin: determine origin point and record it to the parent Sprite.
        else if (layer == "_origin")
        {
            if (cel.Pixels.Length > 1)
            {
                // We could technically just traverse all the pixels and find the first one with a high alpha value... but it's better to just make people do it right.
                Console.WriteLine("[ERROR]: Sprite " + parent.Name + " has an origin layer with more than one pixel. This may be due to an uncropped canvas. Ungracefully exiting packing!!!");
                throw new Exception("Please see the above error message.");
            }
            
            parent.OriginX = cel.X;
            parent.OriginY = cel.Y;
        }
    }

    #endregion
    
    
    
    #region ENUMS
    
    /// <summary>
    /// Generates and writes an enum to a .cs file.
    /// </summary>
    /// <param name="name">The name of the enum.</param>
    /// <param name="nameSpace">The namespace to which the enum belongs.</param>
    /// <param name="contents">List of strings to be turned into enum members.</param>
    /// <param name="outDir">Output directory for this enum file.</param>
    private static void WriteEnum(string name, string nameSpace, List<string> contents, DirectoryInfo outDir)
    {
        var enumOut = ENUM_FILE_HEADER + "namespace " + nameSpace + ";\n\npublic enum " + name + " {";

        var finalEntries = contents.Distinct().ToList();

        foreach (var entry in finalEntries)
        {
            enumOut += "\n\t" + entry + ",";
        }

        enumOut += "\n}";
        
        File.WriteAllText(outDir.FullName + "/" + name + ".cs", enumOut);
    }
    
    #endregion
}