using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp.Processing;
using TexturePacker.Models;

namespace TexturePacker;

public static class Packer
{
    private static readonly List<Sprite> Sprites = new();
    private static readonly List<Frame> Frames = new();
    private static string _exportJson = "{\"sprites\":{\n";

    private const string ENUM_FILE_HEADER = @"
/*
 * WARNING: This file is auto-generated by the texture packer!!!
 *          Modifications to it will be overwritten the next time the texture packer is run.
 */


";

    public static void PackAllPages(DirectoryInfo dir, DirectoryInfo outDir)
    {
        foreach (var page in dir.GetDirectories())
        {
            PackPage(page, outDir);
        }
    }

    public static void PackPage(DirectoryInfo dir, DirectoryInfo outDir)
    {
        var options = File.Exists(dir + "/PageOptions.json") 
            ? PageOptions.FromJson(File.ReadAllText(dir + "/PageOptions.json")) 
            : new PageOptions();

        var name = dir.Name;
        
        LoadSprites(dir);

        // Sort list from largest to smallest. I am lying to the computer here to get the largest images FIRST (inverting 1/-1).
        Frames.Sort(delegate(Frame x, Frame y)
        {
            // X is smaller
            if (x.Height < y.Height)
                return 1;

            // Y is smaller
            if (y.Height < x.Height)
                return -1;

            // Both are equal
            return 0;
        });
        
        Node root = new(new Rectangle(0, 0, options.Size, options.Size));

        foreach (var frame in Frames)
        {
            var node = root.Insert(frame.Data);
            if (node != null)
            {
                frame.Parent.Positions[frame.Layer][frame.Index] = new FakeRectangle(node.Bounds.X + 1, 
                    node.Bounds.Y + 1, node.Bounds.Width - 2, node.Bounds.Height - 2);
            }
        }
        
        var enumOutput = "";

        foreach (var sprite in Sprites)
        {
            _exportJson += sprite + ",\n";
            enumOutput += sprite.Name + ",\n";
        }

        _exportJson += "}}";
        
        File.WriteAllText(outDir + "/" + name + ".json", _exportJson);

        if (!Directory.Exists(outDir + "/enums"))
            Directory.CreateDirectory(outDir + "/enums");
        
        File.AppendAllText(outDir + "/enums/pages.enumPart", name + ",\n");
        
        if (!Directory.Exists(outDir + "/enums/sprites"))
            Directory.CreateDirectory(outDir + "/enums/sprites");
        
        File.WriteAllText(outDir + "/enums/sprites/" + name + ".enumPart", enumOutput);
        
        Image<Rgba32> canvas = new(options.Size, options.Size);
        
        root.Render(canvas);
        
        canvas.SaveAsPng(outDir + "/" + name + ".png");
    }

    private static readonly List<Image<Rgba32>> Images = new();

    private static List<string> MapLayers(Aseprite aseprite)
    {
        var output = new List<string>();

        foreach (var layer in aseprite.Layers)
        {
            if (layer.Name.StartsWith('_'))
                continue;
            
            output.Add(layer.Name);
        }

        return output;
    }

    private static void Crop(this Image<Rgba32> img, Sprite parent, int layerIndex, int index)
    {
        var cropLeft = img.Width;
        var cropRight = 0;
        var cropTop = img.Height;
        var cropBottom = 0;

        for (var i = 0; i < img.Width; i++)
        {
            for (var j = 0; j < img.Height; j++)
            {
                if (img[i, j].A <= 0) 
                    continue;
    
                if (i < cropLeft)
                    cropLeft = i;
                if (i > cropRight)
                    cropRight = i;

                if (j < cropTop)
                    cropTop = j;
                if (j > cropBottom)
                    cropBottom = j;
            }
        }

        if (cropLeft != 0 || cropRight != img.Width || cropTop != 0 || cropBottom != img.Height)
            img.Mutate(x => x.Crop(new Rectangle(cropLeft, cropTop, 
                    1 + cropRight - cropLeft, 1 + cropBottom - cropTop))
                .Pad(img.Width + 2, img.Height + 2));
        
        //Console.WriteLine(cropLeft + ", " + cropTop + ", " + cropRight + ", " + cropBottom);
        
        //parent.CropOffsets[layerIndex][index] = new[] { cropLeft, cropTop };
    }

    private static void ParseCelData(Aseprite.Cel cel, Sprite parent, int index, List<string> layers, 
        Dictionary<string, Dictionary<int, int[]>> attachPoints)
    {
        var layer = cel.Layer.Name;

        if (!layer.StartsWith('_'))
        {
            // if you're wandering in here wondering why special blend modes are busted it's probably because we are
            // directly reading the bytes into an image. I do not care about this behavior right now so I'm not doing
            // the extra work to support it but you probably want to add some stuff to Aseprite.cs and then read pixels
            // instead of bytes
            var img = Image.LoadPixelData<Rgba32>(cel.Bytes, cel.Width, cel.Height);
            var layerIndex = layers.IndexOf(layer);
            
            img.Crop(parent, layerIndex, index);
            
            Frames.Add(new Frame(img, parent, index, layerIndex));
        }
        // Attach points
        else if (layer.StartsWith("_attach_"))
        {
            var name = layer.Replace("_attach_", "");

            attachPoints[name][index] = new[] { cel.X, cel.Y };
        }
        // Origin
        else if (layer == "_origin")
        {
            parent.OriginX = cel.X;
            parent.OriginY = cel.Y;
        }
    }

    public static void LoadSprites(DirectoryInfo directory)
    {
        foreach (var file in directory.GetFiles())
        {
            if (file.Extension == ".aseprite")
            {
                Console.WriteLine(file.Name + ":");
                
                var ase = new Aseprite(file.FullName);

                var layers = MapLayers(ase);

                var sprite = new Sprite(Path.GetFileNameWithoutExtension(file.Name), ase.Width, ase.Height, layers.Count, ase.FrameCount);
                
                Sprites.Add(sprite);

                int i;
                for (i = 0; i < sprite.Layers; i++)
                {
                    sprite.CropOffsets[i] = new int[sprite.Length][];
                    sprite.Positions[i] = new FakeRectangle[sprite.Length];
                }

                var attachPoints = new Dictionary<string, Dictionary<int, int[]>>();
                
                foreach (var layer in ase.Layers)
                {
                    if (!layer.Name.StartsWith("_attach_")) 
                        continue;
                    
                    var name = layer.Name.Replace("_attach_", "");
                    attachPoints[name] = new Dictionary<int, int[]>();
                }
                
                for (i = 0; i < ase.FrameCount; i++)
                {
                    foreach (var cel in ase.Frames[i].Cels)
                    {
                        ParseCelData(cel, sprite, i, layers, attachPoints);
                    }
                }

                foreach (var layer in attachPoints.Keys)
                {
                    var count = attachPoints[layer].Count;
                    sprite.AttachPoints[layer] = new int[count][];
                    
                    for (i = 0; i < count; i++)
                    {
                        sprite.AttachPoints[layer][i] = attachPoints[layer][i];
                    }
                }
            }
        }
    }

    /*
    public static void Enum(DirectoryInfo dir, FileSystemInfo output, string name, string nameSpace)
    {
        var enumOut = ENUM_FILE_HEADER + "namespace " + nameSpace + ";\n\npublic enum " + name + " {";

        List<string> entries = new();
        
        foreach (var file in dir.GetFiles())
        {
            var all = File.ReadAllText(file.FullName);
            var lines = all.Split("\n");
            foreach (var line in lines)
            {
                entries.Add(line);
            }
        }

        var finalEntries = entries.Distinct().ToList();

        foreach (var entry in finalEntries)
        {
            enumOut += "\n\t" + entry;
        }

        enumOut += "\n}";

        File.WriteAllText(output.FullName, enumOut);
    }

    public static void Pack(DirectoryInfo dir, int size, DirectoryInfo outDir, string name)
    {
        // Add sprites to list
        RecursiveAdd(dir);

        // Sort list from largest to smallest. I am lying to the computer here to get the largest images FIRST (inverting 1/-1).
        Frames.Sort(delegate(Frame x, Frame y)
        {
            // X is smaller
            if (x.Height < y.Height)
                return 1;

            // Y is smaller
            if (y.Height < x.Height)
                return -1;

            // Both are equal
            return 0;
        });

        Node root = new(new Rectangle(0, 0, size, size));

        var enumOutput = "";

        foreach (var frame in Frames)
        {
            var node = root.Insert(frame);
            if (node != null)
            {
                frame.Parent.Positions[frame.Index] = new FakeRectangle(node.Bounds.X + 1, node.Bounds.Y + 1, node.Bounds.Width - 2,
                    node.Bounds.Height - 2);
            }
        }

        foreach (var sprite in Sprites)
        {
            _exportJson += sprite + ",\n";
            enumOutput += sprite.Metadata.Name + ",\n";
        }

        _exportJson += "}}";

        File.WriteAllText(outDir + "/" + name + ".json", _exportJson);

        if (!Directory.Exists(outDir + "/enums"))
            Directory.CreateDirectory(outDir + "/enums");

        

        File.AppendAllText(outDir + "/enums/pages.enumPart", name + ",\n");

        if (!Directory.Exists(outDir + "/enums/sprites"))
            Directory.CreateDirectory(outDir + "/enums/sprites");
        
        File.WriteAllText(outDir + "/enums/sprites/" + name + ".enumPart", enumOutput);

        Image<Rgba32> canvas = new(size, size);

        root.Render(canvas);

        canvas.SaveAsPng(outDir + "/" + name + ".png");
    }

    public static void RecursiveAdd(DirectoryInfo directory)
    {
        FileInfo? metadata = null;
        List<string> names = new();
        List<Image> frames = new();

        foreach (var file in directory.GetFiles())
        {
            if (file.Extension == ".png")
                names.Add(file.FullName);
            else if (file.Name == "mdat.json")
                metadata = file;
        }
        
        names.Sort((strX, strY) =>
        {
            var x = int.Parse(Path.GetFileNameWithoutExtension(strX));
            var y = int.Parse(Path.GetFileNameWithoutExtension(strY));

            if (x == y) 
                return 0;

            return x < y ? -1 : 1;
        });

        var trueWidth = 0;
        var trueHeight = 0;
        
        var cropOffsets = new int[names.Count][];
        
        for (var n = 0; n < names.Count; n++)
        {
            var name = names[n];
            var img = Image.Load<Rgba32>(name);

            if (n == 0)
            {
                trueWidth = img.Width;
                trueHeight = img.Height;
            }
            
            var cropLeft = img.Width;
            var cropRight = 0;
            var cropTop = img.Height;
            var cropBottom = 0;

            for (var i = 0; i < img.Width; i++)
            {
                for (var j = 0; j < img.Height; j++)
                {
                    if (img[i, j].A <= 0) 
                        continue;
                    
                    if (i < cropLeft)
                        cropLeft = i;
                    if (i > cropRight)
                        cropRight = i;

                    if (j < cropTop)
                        cropTop = j;
                    if (j > cropBottom)
                        cropBottom = j;
                }
            }
            
            if (cropLeft != 0 || cropRight != img.Width || cropTop != 0 || cropBottom != img.Height)
                img.Mutate(x => x.Crop(new Rectangle(cropLeft, cropTop, 1 + cropRight - cropLeft, 1 + cropBottom - cropTop)).Pad(img.Width + 2, img.Height + 2));

            frames.Add(img);
            
            cropOffsets[n] = new[] { cropLeft, cropTop };
        }

        if (metadata != null)
        {
            var spr = new Sprite(metadata, trueWidth, trueHeight, cropOffsets);
            
            Sprites.Add(spr);
            for (var i = 0; i < frames.Count; i++)
            {
                Frames.Add(new Frame(frames[i], spr, i));
            }
        }

        foreach (var dir in directory.GetDirectories())
        {
            RecursiveAdd(dir);
        }
    }
    
    */
}